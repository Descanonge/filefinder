"""Test regex generation from format string.

All possible formats are tested using a mixture of pytest parametrization and
hypothesis (for fill character, width and precision).

For each generated format object, and any number (using hypothesis):
* check that the generated regex match the formatted number
* check that we can parse the number back
"""

import itertools
import re
import typing as t

import pytest
from filefinder.format import (
    DangerousFormatError,
    Format,
    FormatAbstract,
    FormatError,
    FormatFloat,
    FormatInteger,
)
from hypothesis import given
from hypothesis import strategies as st
from util import FormatChoices, StFormat, StructFormat


def assert_regex_match(value: t.Any, fmt: FormatAbstract):
    """Check if a value formatted by Format is parsed by Format."""
    string = fmt.format(value)
    pattern = fmt.generate_expression()
    m = re.fullmatch(pattern, string)
    assert (
        m is not None
    ), f"No match. Format '{fmt.fmt}'. Pattern '{pattern}'. String '{string}'"


def assert_parse_int(number: int, fmt: FormatInteger):
    """Assert Format parse correctly a value it has formatted."""
    string = fmt.format(number)
    parsed = fmt.parse(string)
    assert (
        number == parsed
    ), f"Not parsed. Format '{fmt.fmt}'. Number '{number}'. Parsed '{parsed}'"


def assert_parse_float(number: float, fmt: FormatFloat, precision: str, kind="f"):
    """Assert Format parse correctly a float value it has formatted.

    Has to deal with precision here,
    """
    string_ref = f"{{:{precision}{kind}}}".format(number)
    parsed_ref = float(string_ref)

    string = fmt.format(number)
    parsed = fmt.parse(string)
    assert (
        parsed_ref == parsed
    ), f"Not parsed. Format '{fmt.fmt}'. Number '{number}'. Parsed '{parsed}'"


# Start by quick tests where the whole format is generated by hypothesis
# This allows to test the generation (which is used in other tests)


@given(struct=StFormat.format(kind="d", safe=True), number=st.integers())
def test_format_quick_d(struct: StructFormat, number: int):
    """Test integer format."""
    f = t.cast(FormatInteger, Format(struct.fmt))
    assert_regex_match(number, f)
    assert_parse_int(number, f)


@given(
    struct=StFormat.format(kind="feE", safe=True),
    number=st.floats(allow_infinity=False, allow_nan=False),
)
def test_format_quick_feE(struct: StructFormat, number: float):
    """Test float format."""
    f = t.cast(FormatFloat, Format(struct.fmt))
    assert_regex_match(number, f)
    assert_parse_float(number, f, struct.precision_str, struct.kind)


@given(
    struct=StFormat.format(kind="s"),
    value=st.text(alphabet=st.characters(exclude_categories=["C"])),
)
def test_format_quick_s(struct: StructFormat, value: str):
    """Test string format."""
    if struct.align == "=":
        with pytest.raises(FormatError):
            Format(struct.fmt)
        return

    f = Format(struct.fmt)
    s = f.format(value)
    assert_regex_match(s, f)


# Now we test by looping over every possible combination of parameters (excepted
# the fill, width, and precision which are generated by hypothesis)


@given(fill=StFormat.fill(), width=StFormat.width(), number=st.integers())
def test_format_d(fill: str, width: int, number: int):
    """Test integer formats (type d)."""
    for struct in StFormat.loop_over(ignore=["alt"], width=width, fill=fill, kind="d"):
        try:
            fmt = t.cast(FormatInteger, Format(struct.fmt))
        except DangerousFormatError:
            return
        assert_regex_match(number, fmt)
        assert_parse_int(number, fmt)


@given(
    fill=StFormat.fill(),
    width=StFormat.width(),
    precision=StFormat.precision(),
    number=st.floats(allow_nan=False, allow_infinity=False),
)
def test_format_feE(fill: str, width: int | None, precision: int | None, number: float):
    """Test float formats (type f and e)."""
    for kind in "feE":
        for struct in StFormat.loop_over(width=width, fill=fill, kind=kind):
            try:
                f = t.cast(FormatFloat, Format(struct.fmt))
            except DangerousFormatError:
                return
            assert_regex_match(number, f)
            assert_parse_float(number, f, struct.precision_str, kind)


@given(
    fill=StFormat.fill(),
    width=StFormat.width(),
    value=st.text(alphabet=st.characters(exclude_categories=["C"])),
)
def test_format_s(fill: str, width: int | None, value: str):
    """Test string formats (type s)."""
    for struct in StFormat.loop_over(
        ignore=["sign", "alt", "zero", "grouping"], width=width, fill=fill, kind="s"
    ):
        if struct.align == "=":
            with pytest.raises(FormatError):
                Format(struct.fmt)
            return

        fmt = Format(struct.fmt)
        s = fmt.format(value)
        assert_regex_match(s, fmt)


@pytest.mark.parametrize(
    "fmt",
    [">05d", "4>5d", "4<5f", "2^3d", "-^6f"],
)
def test_dangerous_formats(fmt: str):
    """Test ambiguous formats."""
    with pytest.raises(DangerousFormatError):
        Format(fmt)
